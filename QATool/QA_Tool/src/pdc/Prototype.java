/**
 * Prototype.java Copyright (c) 2016, Carolla Development, Inc. All Rights Reserved
 * 
 * Permission to make digital or hard copies of all or parts of this work for commercial use is
 * prohibited. To republish, to post on servers, to reuse, or to redistribute to lists, requires
 * prior specific permission and/or a fee. Request permission to use from Carolla Development, Inc.
 * by email: acline@carolla.com
 */

package pdc;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Scanner;
import java.util.regex.Pattern;

import mylib.Constants;

/**
 * @author Alan Cline
 * @version Jan 29, 2016 // original <br>
 */
public class Prototype
{
   private final String COMMA = ",";
   private final String DOT = ".";
   private final String SPACE = " ";
   private final String LEFT_PAREN = "(";
   private final String RIGHT_PAREN = ")";
   private final String LEFT_BRACE = "{";
   private final String RIGHT_BRACE = "}";

   /** Set of JUnit import statements */
   private final String JUNIT_IMPORTS =
         "import static org.junit.Assert.*; \n" +
               "import org.junit.After; \n" +
               "import org.junit.AfterClass; \n" +
               "import org.junit.Before; \n" +
               "import org.junit.BeforeClass; \n" +
               "import org.junit.Test; \n\n" +
               "import mylib.MsgCtrl;\n";

   /** Class header comments, author, and version and definition */
   private final String AUTHOR_VERSION =
         "/** \n * @author --generated by QA Tool--\n" +
               " * @version %1$tB %1$te, %1$tY \t// original <br>\n */\n" +
               "public class %2$s\n{";

   /** Class header comments, author, and version and definition */
   private final String AUGMENT_VERSION =
         " *          %1$tB %1$te, %1$tY \t// autogen: QA Tool added missing test methods <br>";

   /** Standard setup and teardown methods */
   private final String PREP_DECLARE =
         "\t/** \n\t * @throws java.lang.Exception\n \t */ \n\t" +
               "%s\n\tpublic %svoid %s throws Exception\n\t{ }\n\n";

   /** BEGIN TESTS Banner */
   private final String DBL_HRULE =
         "// ===============================================================================\n";
   private final String BANNER =
         "\n\t" + DBL_HRULE + "\t// TESTS FOR %s METHODS\n\t" + DBL_HRULE;

   /**
    * Test method template: @Normal annotation, @Test annotation, declaration, MsgCtrl block private
    */
   private final String NORMAL_CMT = "\t/**\n \t * @NORMAL_TEST %s\n\t */";
   private final String TEST_ANNOT = "\n\t@Test\n";
   private final String M_DECLARATION = "\tpublic void %s\n\t{\n";
   private final String MSGCTRL_BLOCK = "\t\tMsgCtrl.auditMsgsOn(false);\n" +
         "\t\tMsgCtrl.errorMsgsOn(false);\n" +
         "\t\tMsgCtrl.where(this);\n\n" +
         "\t\tfail(\"\\t\\tNot yet implemented\");";

   /** Sort the methods by modifer: public, protected, private */
   // ArrayList<String> _publics = new ArrayList<String>();
   // ArrayList<String> _protecteds = new ArrayList<String>();


   // ======================================================================
   // CONSTRUCTOR
   // ======================================================================

   // Default constructor
   public Prototype()
   {}

   // ======================================================================
   // PUBLIC METHODS
   // ======================================================================


   /**
    * Copy an existing test file, adding missing test methods (that fail) from its corresponding
    * source file.
    * 
    * @param target existing test file to update
    * @param srcList signatures of source method names used in test file comments
    * @param auglist new methods to write to the output file
    * @return the test file written
    */
   public File augmentTestFile(File target, ArrayList<String> srcList, ArrayList<String> augList)
   {
      // Create new I/O devices to read and copy file
      Scanner in = null;
      PrintWriter out = null;
      File tmpFile = null;
      // Create temp file to write to until finished
      String tmpName = target.getPath();
      tmpName = tmpName.replace(".java", ".tmp");
      tmpFile = new File(tmpName);

      try {
         in = new Scanner(target);
         out = new PrintWriter(tmpFile);
      } catch (FileNotFoundException e) {
         System.err.println("\tPrototype.augmentTestFile(): \t" + e.getMessage());
         return null;
      }

      // Add a new version line to the existing file
      addVersionLine(in, out, AUGMENT_VERSION);

      // Go to the end of class to insert new methods
      String line = findClassEnd(in, out);

      writeCodeBlocks(out, srcList, augList);

      // Copy out the class-end and close the file
      auditPrint(out, line);

      in.close();
      out.close();

      // Replace the old test file with the new test file
      target.delete();
      tmpName = tmpName.replace(".tmp", ".java");
      tmpFile.renameTo(new File(tmpName));
  
      return tmpFile;
   }


   /**
    * Return the source {@code Class} for the given source java file
    * 
    * @param sourceText the fully-qualifed (with package name) {@code .java} source filename
    * @param root the directory prefix to be removed to get the sourceText file
    * @return the equivalent {@.class} file
    */
   public Class<?> convertSourceToClass(String sourceText)
   {
      // Remove the file extension
      String className = sourceText.split(".java")[0];
      // Convert the file path format to package format by replacing the "/" with "." or "\" with
      // Windoze
      className = className.replaceAll(Pattern.quote(Constants.FS), ".");
      // Remove any prefix that ends with "src/"
      className = className.substring(className.lastIndexOf("src.") + 2);
      // Replace src with bin
      Class<?> sourceClass = null;
      try {
         sourceClass = Class.forName(className);
      } catch (ClassNotFoundException ex) {
         System.err.println("\tconvertSourceToClass(): " + className + ".class file not found");
      }
      if (sourceClass == null) {
         System.err.println("\tEnsure that " + sourceText
               + " has been compiled and exists in the bin directory");
      }
      return sourceClass;
   }


   /**
    * Return the class method signature without package context or throws clauses, but with its
    * return type, formatted as: <br>
    * {@code  methodName(argType, argType) : returnType} <br>
    * where each of the Types are their simple names.
    * 
    * @param m the Method object to get full path and properties returned by Class.getMethod()
    * @param anchorName simple name of the class under reflection
    * @return the method signature, e.g. as is used in the test method comment
    */
   public String extractSignature(Method m, String anchorName)
   {
      String s = m.toString();
      // Skip any method names that do not have the anchorName in it (synthetic classes) and a
      // 'main'
      if ((!s.contains(anchorName)) || (s.contains("main("))) {
         return null;
      }
      // Remove any throws clauses
      if (s.contains("throws")) {
         s = s.substring(0, s.indexOf("throws"));
      }

      // Remove the modifer
      s = s.substring(s.indexOf(SPACE) + 1);
      String retType = simplifyReturnType(s);
      String methodDecl = simplifyDeclaration(s);
      return (retType + " " + methodDecl);
   }


   /**
    * Sort all method names and number overloaded methods. The Methods are not in any particular
    * order, so the bare method name must be sorted a little first.
    * 
    * @param mList list of method names to check
    * @param mSig signature to check for uniqueness, and possibly increment for number
    */
   public ArrayList<String> forceUnique(ArrayList<String> mList)
   {
      if (mList.size() <= 1) {
         return mList;
      }
      // All signatures must be sorted for this to work
      sortSignatures(mList);

      // Get first sig to get started
      for (int k = 0; k < mList.size() - 1; k++) {
         String firstSig = mList.get(k);
         String firstName = extractNameOnly(firstSig);
         String nextSig = mList.get(k + 1);
         String nextName = extractNameOnly(nextSig);
         // First get bare name for comparison
         // Check if overloaded methods are in list
         if (nextName.equals(firstName)) {
            String[] names = numerateNames(firstSig, nextSig);
            // Replace old names with modified names
            mList.remove(k);
            mList.add(k, names[0]);
            mList.remove(k + 1);
            mList.add(k + 1, names[1]);
         } else {
            continue;
         }
      }
      return mList;
   }


   // /**
   // * Copy the file until the @version block is reached, then add a new version line.
   // *
   // * @param in file to read from
   // * @param out file to rite to
   // */
   // private void updateVersion(Scanner in, PrintWriter out)
   // {
   // boolean inBlock = false;
   // while (in.hasNextLine()) {
   // String line = in.nextLine();
   // out.println(line);
   // if (line.contains("@version")) {
   // inBlock = true;
   // while (line = in.nextLine()) {
   // if (line.contains("@version")) {
   //
   // }
   //
   // }
   // }
   // // Add in the new version line
   // String version = String.format(AUGMENT_VERSION, new Date());
   // out.println(version);
   // break;
   // }
   // }


   /**
    * Writes a prototype test template with JUnit test stubs and Chronos-specific data
    * 
    * @param target prototype test file to write into
    * @param srcList signatures of source method names used in test file comments
    * @param tstlist test method names to write to the output file
    * @return the test file written
    */
   // public File writeFile(File target, String source)
   public File writeNewTestFile(File target, ArrayList<String> srcList, ArrayList<String> tstList)
   {
      // Create new output device
      PrintWriter out = null;
      try {
         // Ensure that the target file is created anew
         target.delete();
         out = new PrintWriter(target);
      } catch (FileNotFoundException e) {
         System.err.println("\twriteFile(): \t" + e.getMessage());
         return null;
      }

      // 1. Write the copyright notice into the prototype
      int year = new GregorianCalendar().get(Calendar.YEAR);
      String copyright = String.format(Constants.COPYRIGHT, target.getName(), year);
      out.println(copyright);

      // 2. Write the package statements for this test class
      String pkgStatement = convertSourceToPackage(target);
      out.println(pkgStatement);

      // 3. Write the JUnit import statements
      out.println(JUNIT_IMPORTS);

      // 4. Write header comment, author, and version
      // Remove the .java extension from the filename
      String className = target.getName();
      int ndx = className.lastIndexOf(".");
      String name = className.substring(0, ndx);
      String version = String.format(AUTHOR_VERSION, new Date(), name);
      out.println(version);

      // 5. Write the four JUnit setup and teardown methods
      out.println(buildPrepMethods());

      // 6. Accummulate and sort test methods by modifier
      // getMethods(sourceClass);
      // ArrayList<String> publics = extractMethodSubset(mlist, "public ");
      // ArrayList<String> protecteds = extractMethodSubset(mlist, "protected ");


      // 7a. Write the public methods beneath a public banner
      // writeCodeBlocks(out, publics, Banner.PUBLIC);
      // writeCodeBlocks(out, protecteds, Banner.PROTECTED);
      writeCodeBlocks(out, srcList, tstList);

      // 8. Write the class closing brace
      out.println(String.format("} \t// end of %s class", target.getName()));

      out.close();
      return target;
   }

   /**
    * Add a new version after the last version line in the class comment block
    * 
    * @param in scanner for reading original file
    * @param out output file for receiving new version
    * @param versionLine to insert in the class comment block
    */
   private void addVersionLine(Scanner in, PrintWriter out, String versionLine)
   {
      boolean inVersionBlock = false;
      String line = null;

      line = copyUntil(in, out, "@version");
      auditPrint(out, line);
      inVersionBlock = true;
      if (inVersionBlock) {
         line = copyUntil(in, out, "*/");
         String version = String.format(versionLine, new Date());
         auditPrint(out, version);
         auditPrint(out, line);
      }
   }

   private void auditPrint(PrintWriter out, String msg)
   {
      out.println(msg);
      QAUtils.outMsg(true, msg);
   }

   /**
    * Copy lines of a file until a given keyWord is reached.
    * 
    * @param in file to read from
    * @param out file to rite to
    * @param keyWord tells input reader to stop copying
    * @return current line of input containing keyword
    */
   private String copyUntil(Scanner in, PrintWriter out, String keyWord)
   {
      String line = null;
      while (in.hasNextLine()) {
         line = in.nextLine();
         if (line.contains(keyWord)) {
            break;
         } else {
            auditPrint(out, line);
         }
      }
      return line;
   }


   // ======================================================================
   // PRIVATE HELPER METHODS
   // ======================================================================

   /** Writes the setUp and tearDown methods at the method and class level */
   private String buildPrepMethods()
   {
      String staticStr = "static ";
      String[] arg = {"@BeforeClass", "setUpBeforeClass()", "@AfterClass", "tearDownAfterClass()",
            "@Before", "setUp()", "@After", "tearDown()"};

      StringBuilder block = new StringBuilder();
      for (int k = 0; k < arg.length; k = k + 2) {
         if (k > 2) {
            staticStr = ""; // only the class setup and teardown uses the static qualifier
         }
         block.append(String.format(PREP_DECLARE, arg[k], staticStr, arg[k + 1]));
      }
      // Before returning, turn off audit and errors messages in tearDown()
      // Insert the MsgCtrl statements before the closing brace;
      String msgFlags = "\n\t\tMsgCtrl.auditMsgsOn(false);\n\t\tMsgCtrl.errorMsgsOn(false);\n\t}\n";
      int ndx = block.lastIndexOf("}");
      block.replace(ndx, block.length(), msgFlags);

      return block.toString();
   }


   /**
    * Write test methods for each of the source methods, with the source methods signature in a
    * preceding comment.
    * 
    * @param srcList signatures of source methods
    * @param tstList list of method declaration from which to derive test methods
    * @return list of test method code blocks for each test method
    */
   private ArrayList<String> buildTestMethods(ArrayList<String> srcList,
         ArrayList<String> tstList)
   {
      // // Guard against the source and test methods not the same size list
      // if (srcList.size() != tstList.size()) {
      // System.err.println("Source messages and test messages out of sync.");
      // return null;
      // }

      // List to return
      ArrayList<String> codeBlock = new ArrayList<String>();

      for (int k = 0; k < tstList.size(); k++) {
         StringBuilder comment = new StringBuilder();
         // CREATE THE NORMAL COMMENT BLOCK containing the source signature
         comment.append(String.format(NORMAL_CMT, srcList.get(k)));
         // Add the @Test annotation
         comment.append(TEST_ANNOT);

         // ADD THE TEST DECLARATIAON
         String m = tstList.get(k);
         // StringBuilder mName = new StringBuilder();
         // int startNdx = m.indexOf(" ");
         // int endNdx = m.indexOf("(");
         // mName.append(m.substring(startNdx + 1, endNdx));
         // // Uppercase the first letter of the method name for the decl
         // String ch = mName.substring(0, 1);
         // mName.replace(0, 1, ch.toUpperCase());
         // Pull off the method name only, which is between the first space and the first '('
         String decl = String.format(M_DECLARATION, m);
         comment.append(decl);

         // ADD THE MSGCTRL BLOCK
         comment.append(MSGCTRL_BLOCK + "\n\t}\n");

         // WRITE OUT THE TEST METHOD
         codeBlock.add(comment.toString());
      }

      return codeBlock;
   }


   /**
    * Return the package statement for the given source file
    * 
    * @param target test file to write out
    * @return the package statement path
    */
   private String convertSourceToPackage(File target)
   {
      String s = target.getParentFile().getAbsolutePath();
      s = s.substring(s.lastIndexOf("src" + Constants.FS));
      s = s.substring(4); // remove the src/
      String pathName = s.replaceAll(Pattern.quote(Constants.FS), ".");
      String pkgStatement = String.format("\npackage %s;\n", pathName);

      return pkgStatement;
   }


   // /**
   // * Extracts public and protected methods from the source file, sorts each list
   // *
   // * @param clazz target source file
   // * @return list of public method names for the target (includes arguments to methods)
   // */
   // public void getMethods(Class<?> clazz)
   // {
   // // Clear old data from lists
   // _publics.clear();
   // _protecteds.clear();
   //
   // String clazzName = clazz.getSimpleName();
   // Method[] rawMethodList = clazz.getDeclaredMethods();
   // for (Method method : rawMethodList) {
   // int modifiers = method.getModifiers();
   // if (modifiers == 0) {
   // System.err.println("WARNING: " + method.getName()
   // + "() has default access; should have a declared access");
   // }
   // if ((Modifier.isPublic(modifiers)) || (Modifier.isProtected(modifiers))) {
   // String mName = extractSignature(method, clazzName);
   // if (mName != null) {
   // if (Modifier.isPublic(modifiers)) {
   // _publics.add(mName);
   // } else if (Modifier.isProtected(modifiers)) {
   // _protecteds.add(mName);
   // }
   // }
   // }
   // }
   // // Ensure that overloaded method are distinguished by number
   // _publics = forceUnique(_publics);
   // _protecteds = forceUnique(_protecteds);
   // }


   /**
    * Get a subset of method names by key, used for extracting public and protected methods
    * 
    * @param allMethods target list to search
    * @param key any keyword by which to extract, usually "public " or "protected "
    * @return the subset that contains the matching keyword
    */
   private ArrayList<String> extractMethodSubset(ArrayList<String> allMethods, String key)
   {
      ArrayList<String> subset = new ArrayList<String>();
      for (String s : allMethods) {
         if (s.contains(key)) {
            subset.add(s);
         }
      }
      // Ensure that overloaded method (duplicate names) are distinguish by number
      subset = forceUnique(subset);
      return subset;
   }


   /**
    * Pull the method name from the signature to compare uniqueness. Any numeric suffix will be
    * ignored
    * 
    * @param mName method signature
    * @return bare name stripped of return value, parm list, and numeric suffix
    */
   private String extractNameOnly(String mName)
   {
      // Extract only the method name
      int pNdx = mName.indexOf(LEFT_PAREN);
      char c = (char) mName.charAt(pNdx - 1);
      if (isDigit(c)) {
         --pNdx;
      }
      int spaceNdx = mName.indexOf(SPACE);
      String shortName = mName.substring(spaceNdx + 1, pNdx);
      return shortName;
   }


   // /**
   // * Extracts public and protected methods from the source file, sorts each list
   // *
   // * @param clazz target source file
   // * @return list of public method names for the target (includes arguments to methods)
   // */
   // public void getMethods(Class<?> clazz)
   // {
   // // Clear old data from lists
   // _publics.clear();
   // _protecteds.clear();
   //
   // String clazzName = clazz.getSimpleName();
   // Method[] rawMethodList = clazz.getDeclaredMethods();
   // for (Method method : rawMethodList) {
   // int modifiers = method.getModifiers();
   // if (modifiers == 0) {
   // System.err.println("WARNING: " + method.getName()
   // + "() has default access; should have a declared access");
   // }
   // if ((Modifier.isPublic(modifiers)) || (Modifier.isProtected(modifiers))) {
   // String mName = extractSignature(method, clazzName);
   // if (mName != null) {
   // if (Modifier.isPublic(modifiers)) {
   // _publics.add(mName);
   // } else if (Modifier.isProtected(modifiers)) {
   // _protecteds.add(mName);
   // }
   // }
   // }
   // }
   // // Ensure that overloaded method are distinguished by number
   // _publics = forceUnique(_publics);
   // _protecteds = forceUnique(_protecteds);
   // }


   /**
    * Find the closing brace at the end of the class so that new methods can be inserted.
    * 
    * @param in scanner for reading original file
    * @param out output file for receiving new version
    * @return line containing the closing brace
    */
   private String findClassEnd(Scanner in, PrintWriter out)
   {
      int delimCnt = 0;
      String line = null;

      while (in.hasNextLine()) {
         line = in.nextLine();
         if (line.contains(LEFT_BRACE)) {
            delimCnt++;
         }
         if (line.contains(RIGHT_BRACE)) {
            delimCnt--;
         }
         // If end of class reached
         if ((line.contains(RIGHT_BRACE)) && (delimCnt == 0)) {
            break;
         } else {
            auditPrint(out, line);
         }
      }
      // Return the line that contains the class closing brace.
      return line;
   }

   /**
    * Determine if the given character is a digit from 1 to 9
    * 
    * @param ch character to check
    * @return true if c is a numeric digit
    */
   private boolean isDigit(char ch)
   {
      return (ch >= '1' && ch <= '9');
   }


   /**
    * Ensure that all subdirs in the long path exist
    * 
    * @param target long path of a file to be created
    * @return the short file name
    */
   private String makeSubtree(File target)
   {
      // Remove filename from end of path
      File subtree = target.getParentFile();
      subtree.mkdirs();
      return subtree.getName();
   }

   /**
    * Insert "test" after the "src" dir, capitalize the original filename, then insert "Test" in
    * front of the filename.
    * 
    * @param srcPath full path of source file
    * @return test file name that corresponds to source file
    */
   public String makeTestFilename(String srcPath)
   {
      // Guard against non-Java files
      if (!srcPath.endsWith(".java")) {
         return null;
      }
      StringBuilder sbTest = new StringBuilder(srcPath);
      int srcTextNdx = srcPath.lastIndexOf("src");
      sbTest.insert(srcTextNdx + 4, "test" + Constants.FS);
      int ndx = sbTest.lastIndexOf(Constants.FS);
      sbTest.insert(ndx + 1, "Test");

      return sbTest.toString();
   }


   /**
    * Number two sorted signatures, then give the second a higher numerical suffix than the first
    * 
    * @Return the numbered signatures first, then the new one, made unique, to add
    */
   private String[] numerateNames(String firstName, String secondName)
   {
      String[] mNames = new String[2];
      StringBuilder sb1 = new StringBuilder(firstName);
      StringBuilder sb2 = new StringBuilder(secondName);
      // Get number of first name
      int paren1 = firstName.indexOf(LEFT_PAREN);
      int paren2 = secondName.indexOf(LEFT_PAREN);
      char c1 = sb1.charAt(paren1 - 1);
      char c2 = '-';
      if (isDigit(c1)) {
         c2 = (char) (c1 + 1);
         sb2.insert(paren2, c2);
      } else {
         // bare name has no numeric suffix
         sb1.insert(paren2, "1");
         sb2.insert(paren2, "2");
      }
      mNames[0] = sb1.toString();
      mNames[1] = sb2.toString();
      return mNames;
   }


   /**
    * Reduce a fully qualified class name to it simplified name by removing the dot-delimited full
    * name to yield the suffix, the simple name. This is used for return types and argument types
    * that occur in the method declaration.<br>
    * The method declaration has format, where each type is a fully qualified type: <br>
    * {@code return-type methodName(argType, argType,...) <br>
    * For example, {@code java.lang.String extractSignature(java.io.File, java.lang.String)} becomes
    * {@code String extractSignature(File, String)}.<br>
    * Note: The ellipsis in the signature example refers to a fixed but indefinite number of
    * arguments, not to a varargs set.
    * 
    * @param decl the fully-qualified method declaration
    * @return the method name and simple argname list
    */
   private String simplifyDeclaration(String decl)
   {
      // Discard the the return type
      decl = decl.trim();
      int rtNdx = decl.indexOf(SPACE);
      decl = decl.substring(rtNdx + 1);

      // Setup buffers to allow characer movement
      StringBuilder sbIn = new StringBuilder(decl);
      StringBuilder sbOut = new StringBuilder();

      // To simplify arguments, walk backwards from the right paren, removing prefixes
      boolean skip = false;
      int in = sbIn.length() - 1;
      for (; in >= 0; in--) {
         char ch = sbIn.charAt(in);
         // Add space character to follow each comma
         if (ch == ',') {
            sbOut.insert(0, SPACE); // new char is placed in front of existing chars
            skip = false;
         } else if (ch == '(') {
            skip = false;
         }
         // Skip all characters between previous comma or left paren and the dot
         else if ((ch == '.') || (skip == true)) {
            skip = true;
            continue;
         }
         sbOut.insert(0, ch);
         // System.out.println(String.format("\tCharacter written: %c", sbOut.charAt(0)));
      }
      String result = sbOut.toString().trim();
      return result;
   }


   /**
    * Convert the fully qualifed return type of a signature into its simple type. Also removes the
    * method modifier (public, private, static, protected).
    * 
    * @param decl fully qualifed method signature, with parm types and return type
    * @return only the simple return type
    */
   private String simplifyReturnType(String decl)
   {
      // Remove trailing and leading white space then make a destination String
      decl = decl.trim();
      String dest = new String(decl);

      int retNdx = decl.indexOf(SPACE); // return type
      String retSig = decl.substring(0, retNdx);
      int lastDot = retSig.lastIndexOf(DOT);
      dest = decl.substring(lastDot + 1, retNdx);

      return dest;
   }

   /**
    * Sort first by method name, then by parm list number and value
    * 
    * @param sList collection of method signatures
    */
   private void sortSignatures(ArrayList<String> sList)
   {
      Collections.sort(sList, new Comparator<String>() {
         @Override
         public int compare(String sig1, String sig2)
         {
            // Tokenize into three parts: method name, parm list, return type
            String name1 = sig1.substring(sig1.indexOf(SPACE) + 1, sig1.indexOf(LEFT_PAREN));
            String name2 = sig2.substring(sig2.indexOf(SPACE) + 1, sig2.indexOf(LEFT_PAREN));
            String parms1 = sig1.substring(sig1.indexOf(LEFT_PAREN), sig1.indexOf(RIGHT_PAREN) + 1);
            String parms2 = sig2.substring(sig2.indexOf(LEFT_PAREN), sig2.indexOf(RIGHT_PAREN) + 1);
            // System.err.println("\t\t sort loops = " + ++count);

            // Compare method names
            int retval = name1.compareTo(name2); // compare method names
            // Compare number of parms and parms names
            if (retval == 0) {
               String[] nbrParms1 = parms1.split(COMMA);
               String[] nbrParms2 = parms2.split(COMMA);
               retval = nbrParms1.length - nbrParms2.length;
               if (retval == 0) {
                  retval = parms1.compareTo(parms2);
               }
            }
            return retval;
         }
      });
   }


   /**
    * Writes the list of methods into file
    * 
    * @param op PrintWriter or output to write code blocks into
    * @param srcList source method signatures for test file comments
    * @param tstList of all methods to write to the test file
    */
   // private void writeCodeBlocks(PrintWriter op, ArrayList<String> methodList, Banner category)
   private void writeCodeBlocks(PrintWriter op, ArrayList<String> srcList,
         ArrayList<String> tstList)
   {
      if (tstList.size() == 0) {
         return;
      }
      ArrayList<String> codeBlock = buildTestMethods(srcList, tstList);
      // op.println(String.format(BANNER, category.toString()));
      for (String s : codeBlock) {
         // System.out.println("\tprotected \t" + s);
         op.println(s);
      }
   }


   // ======================================================================
   // INNER CLASS FOR TESTING
   // ======================================================================

   public class MockPrototype
   {
      public MockPrototype()
      {}


      // public ArrayList<String> getPublicMethods()
      // {
      // return _publics;
      // }
      //
      // public ArrayList<String> getProtectedMethods()
      // {
      // return _protecteds;
      // }

      public Class<?> getSourceClass(String srcPath)
      {
         return Prototype.this.convertSourceToClass(srcPath);
      }

      public void sortSignatures(ArrayList<String> myList)
      {
         Prototype.this.sortSignatures(myList);
      }

   } // end of MockPrototype inner class


} // end of Prototype class
