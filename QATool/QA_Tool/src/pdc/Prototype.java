/**
 * Prototype.java Copyright (c) 2016, Carolla Development, Inc. All Rights Reserved
 * 
 * Permission to make digital or hard copies of all or parts of this work for commercial use is
 * prohibited. To republish, to post on servers, to reuse, or to redistribute to lists, requires
 * prior specific permission and/or a fee. Request permission to use from Carolla Development, Inc.
 * by email: acline@carolla.com
 */

package pdc;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.GregorianCalendar;

import mylib.Constants;

/**
 * @author Alan Cline
 * @version Jan 29, 2016 // original <br>
 */
public class Prototype
{
  private final String COMMA = ",";
  private final String DOT = ".";
  private final String SPACE = " ";
  private final String LEFT_PAREN = "(";
  private final String RIGHT_PAREN = ")";

  /** Categories of methods to put into the test prototype */
  private enum Banner {
    PUBLIC, PROTECTED
  };

  /** Set of JUnit import statements */
  private final String JUNIT_IMPORTS =
      "import static org.junit.Assert.*; \n" +
          "import org.junit.After; \n" +
          "import org.junit.AfterClass; \n" +
          "import org.junit.Before; \n" +
          "import org.junit.BeforeClass; \n" +
          "import org.junit.Test; \n\n" +
          "import mylib.MsgCtrl;\n";


  /** Class header comments, author, and version and definition */
  private final String AUTHOR_VERSION =
      "/** \n * @author --generated by QA Tool--\n" +
          " * @version %1$tB %1$te, %1$tY \t// original <br>\n */\n" +
          "public class %2$s\n{";

  /** Standard setup and teardown methods */
  private final String PREP_DECLARE =
      "\t/** \n\t * @throws java.lang.Exception\n \t */ \n\t" +
          "%s\n\tpublic %svoid %s throws Exception\n\t{ }\n\n";

  /** BEGIN TESTS Banner */
  private final String DBL_HRULE =
      "// ===============================================================================\n";
  private final String BANNER =
      "\n\t" + DBL_HRULE + "\t// TESTS FOR %s METHODS\n\t" + DBL_HRULE;

  /**
   * Test method template: @Normal annotation, @Test annotation, declaration, MsgCtrl block private
   */
  private final String NORMAL_CMT = "\t/**\n \t * @NORMAL_TEST %s\n\t */";
  private final String TEST_ANNOT = "\n\t@Test\n";
  private final String M_DECLARATION = "\tpublic void test%s()\n\t{\n";
  private final String MSGCTRL_BLOCK = "\t\tMsgCtrl.auditMsgsOn(false);\n" +
      "\t\tMsgCtrl.errorMsgsOn(false);\n" +
      "\t\tMsgCtrl.where(this);\n\n" +
      "\t\tfail(\"\\t\\tNot yet implemented\");";

  /** Sort the methods by modifer: public, protected, private */
  ArrayList<String> _publics = new ArrayList<String>();
  ArrayList<String> _protecteds = new ArrayList<String>();


  // ======================================================================
  // CONSTRUCTOR
  // ======================================================================

  // Default constructor
  public Prototype()
  {}


  // ======================================================================
  // PUBLIC METHODS
  // ======================================================================

  /**
   * Insert "test" after the "src" dir, capitalize the original filename, then insert "Test" in
   * front of the filename.
   * 
   * @param srcPath full path of source file
   * @return test file name that corresponds to source file
   */
  public String makeTestFilename(String srcPath)
  {
    // Guard against non-Java files
    if (!srcPath.endsWith(".java")) {
      return null;
    }
    StringBuilder sbTest = new StringBuilder(srcPath);
    int srcTextNdx = srcPath.lastIndexOf("src");
    sbTest.insert(srcTextNdx + 4, "test" + Constants.FS);
    int ndx = sbTest.lastIndexOf(Constants.FS);
    sbTest.insert(ndx + 1, "Test");

    return sbTest.toString();
  }


  /**
   * Writes a prototype test template with JUnit test stubs and Chronos-specific data
   * 
   * @param target prototype test file to write into
   * @param source the java path below the source root subdir from which to derive test methods
   * @return the test file written
   * @throws ClassNotFoundException if the .class file is not found, possibly because it was not
   *           compiled yet
   */
  public File writeFile(File target, String source)
  {
    // Guard Ensure that source file name exists as compiled class name
    Class<?> sourceClass = convertSourceToClass(source);
    if (sourceClass == null) {
      return null;
    }

    // Ensure that all intermediate subdirs exist for the PrintWriter and target file
    makeSubtree(target.getPath());

    // Create new output device
    PrintWriter out = null;
    try {
      // Ensure that the target file is created anew
      target.delete();
      out = new PrintWriter(target);
    } catch (FileNotFoundException e) {
      System.err.println("\twriteFile(): \t" + e.getMessage());
      return null;
    }

    // For readability, remove the root prefixes but keep the subdir references
    String targetPath = target.getPath();
    int cutPoint = targetPath.indexOf("test");
    String shortName = targetPath.substring(cutPoint);
//    System.out.println("\tWriting test class file " + shortName);
    
    // 1. Write the copyright notice into the prototype
    int year = new GregorianCalendar().get(Calendar.YEAR);
    String copyright = String.format(Constants.COPYRIGHT, target.getName(), year);
    out.println(copyright);

    // 2. Write the package statements for this test class
    String pkgStatement = convertSourceToPackage(target);
    out.println(pkgStatement);

    // 3. Write the JUnit import statements
    out.println(JUNIT_IMPORTS);

    // 4. Write header comment, author, and version
    // Remove the .java extension from the filename
    String className = target.getName();
    int ndx = className.lastIndexOf(".");
    String name = className.substring(0, ndx);
    String version = String.format(AUTHOR_VERSION, new Date(), name);
    out.println(version);

    // 5. Write the four JUnit setup and teardown methods
    out.println(buildPrepMethods());

    // 6. Accummulate and sort test methods by modifier
    getMethods(sourceClass); // store lists in class Field

    // 7a. Write the public methods beneath a public banner
    writeCodeBlocks(out, _publics, Banner.PUBLIC);
    writeCodeBlocks(out, _protecteds, Banner.PROTECTED);

    // 8. Write the class closing brace
    out.println(String.format("} \t// end of %s class", target.getName()));

    out.close();
    return target;
  }


  // ======================================================================
  // PRIVATE HELPER METHODS
  // ======================================================================

  /**
   * Sort all method names and number overloaded methods. The Methods are not in any particular
   * order, so the bare method name must be sorted a little first.
   * 
   * @param mList list of method names to check
   * @param mSig signature to check for uniqueness, and possibly increment for number
   */
  private ArrayList<String> forceUnique(ArrayList<String> mList)
  {
    if (mList.size() <= 1) {
      return mList;
    }
    // All signatures must be sorted for this to work
    sortSignatures(mList);

    // Get first sig to get started
    for (int k = 0; k < mList.size() - 1; k++) {
      String firstSig = mList.get(k);
      String firstName = extractNameOnly(firstSig);
      String nextSig = mList.get(k + 1);
      String nextName = extractNameOnly(nextSig);
      // First get bare name for comparison
      // Check if overloaded methods are in list
      if (nextName.equals(firstName)) {
        String[] names = numerateNames(firstSig, nextSig);
        // Replace old names with modified names
        mList.remove(k);
        mList.add(k, names[0]);
        mList.remove(k + 1);
        mList.add(k + 1, names[1]);
      } else {
        continue;
      }
    }
    return mList;
  }


  /**
   * Number two sorted signatures, then give the second a higher numerical suffix than the first
   * 
   * @Return the numbered signatures first, then the new one, made unique, to add
   */
  private String[] numerateNames(String firstName, String secondName)
  {
    String[] mNames = new String[2];
    StringBuilder sb1 = new StringBuilder(firstName);
    StringBuilder sb2 = new StringBuilder(secondName);
    // Get number of first name
    int paren1 = firstName.indexOf(LEFT_PAREN);
    int paren2 = secondName.indexOf(LEFT_PAREN);
    char c1 = sb1.charAt(paren1 - 1);
    char c2 = '-';
    if (isDigit(c1)) {
      c2 = (char) (c1 + 1);
      sb2.insert(paren2, c2);
    } else {
      // bare name has no numeric suffix
      sb1.insert(paren2, "1");
      sb2.insert(paren2, "2");
    }
    mNames[0] = sb1.toString();
    mNames[1] = sb2.toString();
    return mNames;
  }


  /**
   * Determine if the given character is a digit from 1 to 9
   * 
   * @param ch character to check
   * @return true if c is a numeric digit
   */
  private boolean isDigit(char ch)
  {
    return (ch >= '1' && ch <= '9');
  }

  /**
   * Pull the method name from the signature to compare uniqueness. Any numeric suffix will be
   * ignored
   * 
   * @param mName method signature
   * @return bare name stripped of return value, parm list, and numeric suffix
   */
  private String extractNameOnly(String mName)
  {
    // Extract only the method name
    int pNdx = mName.indexOf(LEFT_PAREN);
    char c = (char) mName.charAt(pNdx - 1);
    if (isDigit(c)) {
      --pNdx;
    }
    int spaceNdx = mName.indexOf(SPACE);
    String shortName = mName.substring(spaceNdx + 1, pNdx);
    return shortName;
  }


  /** Writes the setUp and tearDown methods at the method and class level */
  private String buildPrepMethods()
  {
    String staticStr = "static ";
    String[] arg = {"@BeforeClass", "setUpBeforeClass()", "@AfterClass", "tearDownAfterClass()",
        "@Before", "setUp()", "@After", "tearDown()"};

    StringBuilder block = new StringBuilder();
    for (int k = 0; k < arg.length; k = k + 2) {
      if (k > 2) {
        staticStr = ""; // only the class setup and teardown uses the static qualifier
      }
      block.append(String.format(PREP_DECLARE, arg[k], staticStr, arg[k + 1]));
    }
    // Before returning, turn off audit and errors messages in tearDown()
    // Insert the MsgCtrl statements before the closing brace;
    String msgFlags = "\n\t\tMsgCtrl.auditMsgsOn(false);\n\t\tMsgCtrl.errorMsgsOn(false);\n\t}\n";
    int ndx = block.lastIndexOf("}");
    block.replace(ndx, block.length(), msgFlags);

    return block.toString();
  }


  /**
   * Write test methods for each of the source methods
   * 
   * @param methodList list of method declaration from which to derive test methods
   * @return list of test method code blocks for each test method
   */
  private ArrayList<String> buildTestMethods(ArrayList<String> methodList)
  {
    // Return list
    ArrayList<String> codeBlock = new ArrayList<String>();

    // ArrayList<String> methods = getMethods(srcTarget);
    for (String m : methodList) {
      StringBuilder comment = new StringBuilder();
      // CREATE THE NORMAL COMMENT BLOCK
      comment.append(String.format(NORMAL_CMT, m));
      // Add the @Test annotation
      comment.append(TEST_ANNOT);

      // ADD THE TEST DECLARATIAON
      StringBuilder mName = new StringBuilder();
      int startNdx = m.indexOf(" ");
      int endNdx = m.indexOf("(");
      mName.append(m.substring(startNdx + 1, endNdx));
      // Uppercase the first letter of the method name for the decl
      String ch = mName.substring(0, 1);
      mName.replace(0, 1, ch.toUpperCase());
      // Pull off the method name only, which is between the first space and the first '('
      String decl = String.format(M_DECLARATION, mName);
      comment.append(decl);

      // ADD THE MSGCTRL BLOCK
      comment.append(MSGCTRL_BLOCK + "\n\t}\n");

      // WRITE OUT THE TEST METHOD
      codeBlock.add(comment.toString());
      // System.out.println("\n\tbuildTestMethods(): \n" + comment.toString());
    }

    return codeBlock;
  }


  /**
   * Return the source {@code Class} for the given source java file
   * 
   * @param sourceText the {@code .java} source file
   * @return the equivalent {@.class} file
   */
  private Class<?> convertSourceToClass(String sourceText)
  {
    // Remove the file extension
    String className = sourceText.split(".java")[0];
    // Convert the file path format to package format by replacing the "/" with "."
    className = className.replaceAll("/", ".");
    // Remove superfluous dot index
    if (className.startsWith(".")) {
      className = className.substring(1);
    }
    // Replace src with bin
    Class<?> sourceClass = null;
    try {
      sourceClass = Class.forName(className);
    } catch (ClassNotFoundException ex) {
      // System.err.println("\tconvertSourceToClass(): " + className + ".class file not found");
    }
    if (sourceClass == null) {
      System.err.println(
          "\tEnsure that " + sourceText + " has been compiled and exists in the bin directory");
    }
    return sourceClass;
  }


  /**
   * Return the package statement for the given source file
   * 
   * @param target test file to write out
   * @return the package statement path
   */
  private String convertSourceToPackage(File target)
  {
    String s = target.getParentFile().getAbsolutePath();
    s = s.substring(s.lastIndexOf("src/"));
    s = s.substring(4); // remove the src/
    String pathName = s.replaceAll("/", ".");
    String pkgStatement = String.format("\npackage %s;\n", pathName);

    return pkgStatement;
  }


  /**
   * Return the class method signature without package context or throws clauses, but with its
   * return type, formatted as: <br>
   * {@code  methodName(argType, argType) : returnType} <br>
   * where each of the Types are their simple names.
   * 
   * @param m the Method object to get full path and properties returned by Class.getMethod()
   * @param anchorName simple name of the class under reflection
   * @return the method signature, e.g. as is used in the test method comment
   */
  private String extractSignature(Method m, String anchorName)
  {
    String s = m.toString();
    // Skip any method names that do not have the anchorName in it (synthetic classes) and a 'main'
    if ((!s.contains(anchorName)) || (s.contains("main("))) {
      return null;
    }
    // Remove any throws clauses
    if (s.contains("throws")) {
      s = s.substring(0, s.indexOf("throws"));
    }

    // Remove the modifer
    s = s.substring(s.indexOf(SPACE) + 1);
    String retType = simplifyReturnType(s);
    String methodDecl = simplifyDeclaration(s);
    return (retType + " " + methodDecl);
  }


  /**
   * Extracts public and protected methods from the source file, sorts each list
   * 
   * @param clazz target source file
   * @return list of public method names for the target (includes arguments to methods)
   */
  private void getMethods(Class<?> clazz)
  {
    // Clear old data from lists
    _publics.clear();
    _protecteds.clear();

    String clazzName = clazz.getSimpleName();
    Method[] rawMethodList = clazz.getDeclaredMethods();
    for (Method method : rawMethodList) {
      int modifiers = method.getModifiers();
      if (modifiers == 0) {
        System.err.println("WARNING: " + method.getName()
            + "() has default access; should have a declared access");
      }
      if ((Modifier.isPublic(modifiers)) || (Modifier.isProtected(modifiers))) {
        String mName = extractSignature(method, clazzName);
        if (mName != null) {
          if (Modifier.isPublic(modifiers)) {
            _publics.add(mName);
          } else if (Modifier.isProtected(modifiers)) {
            _protecteds.add(mName);
          }
        }
      }
    }
    // Once all methods are collected
    // sortSignatures(_publics);
    // sortSignatures(_protecteds);
    // Ensure that overloaded method are distinguished by number
    _publics = forceUnique(_publics);
    _protecteds = forceUnique(_protecteds);
  }


  /**
   * Ensure that all subdirs in the long path exist
   * 
   * @param path long path of a file to be created
   * @return the short file name
   */
  private String makeSubtree(String path)
  {
    // Remove filename from end of path
    int fnNdx = path.lastIndexOf("/");
    String prefix = path.substring(0, fnNdx);
    File subtree = new File(prefix);
    subtree.mkdirs();
    return path.substring(fnNdx);
  }


  /**
   * Reduce a fully qualified class name to it simplified name by removing the dot-delimited full
   * name to yeild the suffix, the simply name. This is used for return types and argument types
   * that occur in the method declaration.<br>
   * The method declaration has format, where each type is a fully qualified type: <br>
   * {@code return-type methodName(argType, argType,...) <br>
   * For example, {@code java.lang.String extractSignature(java.io.File, java.lang.String)} becomes
   * {@code String extractSignature(File, String)}.<br>
   * Note: The ellipsis in the signature example refers to a fixed but indefinite number of
   * arguments, not to a varargs set.
   * 
   * @param decl the fully-qualified method declaration
   * @return the method name and simple argname list
   */
  private String simplifyDeclaration(String decl)
  {
    // Discard the the return type
    decl = decl.trim();
    int rtNdx = decl.indexOf(SPACE);
    decl = decl.substring(rtNdx + 1);

    // Setup buffers to allow characer movement
    StringBuilder sbIn = new StringBuilder(decl);
    StringBuilder sbOut = new StringBuilder();

    // To simplify arguments, walk backwards from the right paren, removing prefixes
    boolean skip = false;
    int in = sbIn.length() - 1;
    for (; in >= 0; in--) {
      char ch = sbIn.charAt(in);
      // Add space character to follow each comma
      if (ch == ',') {
        sbOut.insert(0, SPACE); // new char is placed in front of existing chars
        skip = false;
      } else if (ch == '(') {
        skip = false;
      }
      // Skip all characters between previous comma or left paren and the dot
      else if ((ch == '.') || (skip == true)) {
        skip = true;
        continue;
      }
      sbOut.insert(0, ch);
      // System.out.println(String.format("\tCharacter written: %c", sbOut.charAt(0)));
    }
    String result = sbOut.toString().trim();
    return result;
  }


  /**
   * Convert the fully qualifed return type of a signature into its simple type. Also removes the
   * method modifier (public, private, static, protected).
   * 
   * @param decl fully qualifed method signature, with parm types and return type
   * @return only the simple return type
   */
  private String simplifyReturnType(String decl)
  {
    // Remove trailing and leading white space then make a destination String
    decl = decl.trim();
    String dest = new String(decl);

    int retNdx = decl.indexOf(SPACE); // return type
    String retSig = decl.substring(0, retNdx);
    int lastDot = retSig.lastIndexOf(DOT);
    dest = decl.substring(lastDot + 1, retNdx);

    return dest;
  }


  /**
   * Sort first by method name, then by parm list number and value
   * 
   * @param sList collection of method signatures
   */
  private void sortSignatures(ArrayList<String> sList)
  {
    Collections.sort(sList, new Comparator<String>() {
      @Override
      public int compare(String sig1, String sig2)
      {
        // Tokenize into three parts: method name, parm list, return type
        String name1 = sig1.substring(sig1.indexOf(SPACE) + 1, sig1.indexOf(LEFT_PAREN));
        String name2 = sig2.substring(sig2.indexOf(SPACE) + 1, sig2.indexOf(LEFT_PAREN));
        String parms1 = sig1.substring(sig1.indexOf(LEFT_PAREN), sig1.indexOf(RIGHT_PAREN) + 1);
        String parms2 = sig2.substring(sig2.indexOf(LEFT_PAREN), sig2.indexOf(RIGHT_PAREN) + 1);
        // System.err.println("\t\t sort loops = " + ++count);

        // Compare method names
        int retval = name1.compareTo(name2); // compare method names
        // Compare number of parms and parms names
        if (retval == 0) {
          String[] nbrParms1 = parms1.split(COMMA);
          String[] nbrParms2 = parms2.split(COMMA);
          retval = nbrParms1.length - nbrParms2.length;
          if (retval == 0) {
            retval = parms1.compareTo(parms2);
          }
        }
        return retval;
      }
    });
  }


  /**
   * Writes the list of methods into file
   * 
   * @param op PrintWriter or output to write code blocks into
   * @param methodList of all methods of the banner category
   * @param category of method for banner, either public or protected
   */
  private void writeCodeBlocks(PrintWriter op, ArrayList<String> methodList, Banner category)
  {
    if (methodList.size() == 0) {
      return;
    }
    ArrayList<String> codeBlock = buildTestMethods(methodList);
    op.println(String.format(BANNER, category.toString()));
    for (String s : codeBlock) {
      // System.out.println("\tprotected \t" + s);
      op.println(s);
    }
  }


  // ======================================================================
  // INNER CLASS FOR TESTING
  // ======================================================================

  public class MockPrototype
  {
    public MockPrototype()
    {}


    public ArrayList<String> getPublicMethods()
    {
      return _publics;
    }

    public ArrayList<String> getProtectedMethods()
    {
      return _protecteds;
    }

    public Class<?> getSourceClass(String srcPath)
    {
      return Prototype.this.convertSourceToClass(srcPath);
    }

    public void sortSignatures(ArrayList<String> myList)
    {
      Prototype.this.sortSignatures(myList);
    }

  } // end of MockPrototype inner class

  
} // end of Prototype class
