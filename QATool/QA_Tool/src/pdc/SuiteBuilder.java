/**
 * SuiteBuilder.java Copyright (c) 2016, Carolla Development, Inc. All Rights Reserved
 * 
 * Permission to make digital or hard copies of all or parts of this work for commercial use is
 * prohibited. To republish, to post on servers, to reuse, or to redistribute to lists, requires
 * prior specific permission and/or a fee. Request permission to use from Carolla Development, Inc.
 * by email: acline@carolla.com
 */

package pdc;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;

import mylib.Constants;

/**
 * Traverse test tree and add test classes found into a test suite, organized by the primary MVP
 * components: PDC, CIV, DMC, and SIC (but not HIC at this time).
 * 
 * @author Alan Cline
 * @version Mar 21, 2016 // original <br>
 */
public class SuiteBuilder
{
  // Error messages
  static private String USAGE_MSG = "USAGE: argument should be root directory of all test files.";
  static private String WRONGARGS_MSG = "Wrong number of arguments given";
  static private String BADDIR_MSG = "Directory given is not a test directory";

  static private int _filesScanned;
  static private int _filesWritten;
  static private int _dirsScanned;

  enum Category {
    BASE, PDC, CIV, DMC, SIC
  };

  /** Collection of file names to write into the Test Suite */
  ArrayList<String> _filenames;

  /** Package statement to insert into suite file */
  private final String PKG_STATEMENT = "package test;\n";

  /** Imports to insert into suite file */
  private final String IMPORTS =
      "import org.junit.runner.RunWith;\n" +
          "import org.junit.runners.Suite;\n" +
          "import test.pdc.TestSuiteBuilder;\n";

  /** Class header comments, author, and version and definition */
  private final String AUTHOR_VERSION =
      "/**\n * Run all unit tests for the project.\n * \n" +
          " * @author --generated by QA Tool--\n" +
          " * @version %1$tB %1$te, %1$tY \t// original <br>\n */\n";

  /** Opening for test class list */
  private final String TEST_LIST = "@RunWith(Suite.class)\n@Suite.SuiteClasses( {\n";

  /** Closing list and empty test suite class definition */
  private final String CLASS_CLOSING = "}) \n\n public class %s { } \n // end of class";

  /** Test group comment */
  private final String GROUP_CMT = "\t\t/** %s Test Files */";


  /** This object */
  static private SuiteBuilder _sb;


  // ======================================================================
  // CONSTRUCTOR
  // ======================================================================

  /** Default constructor */
  public SuiteBuilder()
  {
    _filenames = new ArrayList<String>();
  }

  // ======================================================================
  // PUBLIC METHODS
  // ======================================================================

  /**
   * Given the root test tree, scan all test files from the test directory downward
   * 
   * @param args
   */
  public static void main(String[] args) throws IllegalArgumentException
  {
    // Guards for invalid argument
    if (args.length != 1) {
      throw new IllegalArgumentException(WRONGARGS_MSG);
    }
    File testRoot = new File(args[0]);
    if (!testRoot.isDirectory()) {
      throw new IllegalArgumentException(BADDIR_MSG);
    }
    _sb = new SuiteBuilder();
  }


  /**
   * Recursively traverse the root dir structure, collecting test files
   * 
   * @param testDir test directory root, subdir of srcDir
   * @param rootLen length of the original testDir, a constant throughout recursion
   * @return a list of test classes by subdirectory
   */
  public ArrayList<String> collectTestFileNames(File testDir, int rootlen)
  {
    // Retrieve all files and subdirs under dir
    File[] allFiles = testDir.listFiles();
    for (File f : allFiles) {
      // If file is a directory, recurse down one level
      String path = f.getPath();
      String s = path.substring(rootlen);
      // System.out.println("\tExamining " + s);
      if (f.isDirectory()) {
        _dirsScanned++;
        collectTestFileNames(f, rootlen);
      } else {
        _filesScanned++;
        // Skip HIC subdir
        if (s.contains("hic")) {
          continue;
        }
        // Include only files that start with Test prefix and end with .java suffix
        String fName = f.getName();
        if (fName.endsWith(".java") && (fName.startsWith("Test"))) {
          _filenames.add(s);
        }
      }
    }
    return _filenames;
  }


  /**
   * Writes a test suite for all test classes found, organized by test subdirectory
   * 
   * @param target name of test suite file to write into
   * @param fList the list of all test files to add to suite
   * @return the test file written
   */
  public File writeFile(File target, ArrayList<String> fList)
  {
    // Create new output device
    PrintWriter out = null;
    try {
      // Ensure that the target file is created anew
      target.delete();
      out = new PrintWriter(target);
    } catch (FileNotFoundException e) {
      System.err.println("\twriteFile(): \t" + e.getMessage());
      return null;
    }

    // 1. Write the copyright notice into the prototype
    int year = new GregorianCalendar().get(Calendar.YEAR);
    String copyright = String.format(Constants.COPYRIGHT, target.getName(), year);
    out.println(copyright);

    // 2. Write the package statement
    out.println(PKG_STATEMENT);

    // 3. Write the import statements
    out.println(IMPORTS);

    // 4. Write header comment, author, and version
    // Remove the .java extension from the filename
    String className = target.getName();
    int ndx = className.lastIndexOf(".");
    String name = className.substring(0, ndx);
    String version = String.format(AUTHOR_VERSION, new Date(), name);
    out.println(version);

    // 5. Write the class definition opening
    out.println(TEST_LIST);

    // 6. Replace the .java extension with .class extension for all test filenames
    ArrayList<String> testNames = new ArrayList<String>();
    for (String nm : _filenames) {
      String clsName = nm.replace(".java", ".class,");
      testNames.add(clsName);
    }
    // 6. Write the test class list by group
    writeByGroup(out, testNames);

    // 7. Write the class closing brace
    String s = target.getName();
    String clsName = s.substring(0, s.indexOf(".java"));
    out.println(String.format(CLASS_CLOSING, clsName));

    out.close();
    return target;
  }


  // ======================================================================
  // PRIVATE METHODS
  // ======================================================================

  private void writeByGroup(PrintWriter out, ArrayList<String> fileList)
  {
    ArrayList<String> group = returnGroup(Category.BASE, fileList);
    writeGroup(out, "Base", group);

    group = returnGroup(Category.PDC, fileList);
    writeGroup(out, "PDC", group);

    group = returnGroup(Category.CIV, fileList);
    writeGroup(out, "CIV", group);

    group = returnGroup(Category.DMC, fileList);
    writeGroup(out, "DMC", group);

  }

  /**
   * Write a single named group to the suite
   * 
   * @param out the suite file
   * @param groupName name of the group, from the enum Category
   * @param group list of tests files in this group
   */
  private void writeGroup(PrintWriter out, String groupName, ArrayList<String> group)
  {
    out.println(String.format(GROUP_CMT, groupName));
    for (String nm : group) {
      out.println("\t\t" + nm);
    }
    out.println();
  }


  /** Group test files names by test subdir, returning each group in its own List */
  private ArrayList<String> returnGroup(Category cat, ArrayList<String> nameList)
  {
    ArrayList<String> group = new ArrayList<String>();
    for (String s : nameList) {
      // Check for base tests not in a subdir
      if ((cat == Category.BASE) && (s.startsWith("Test"))) {
        group.add(s);
      } else {
        String prefix = cat.toString().toLowerCase();
        if (s.startsWith(prefix)) {
          // Remove the subdir prefix
          String name = s.substring(s.indexOf(Constants.FS) + 1);
          group.add(name);
        }
      }
    }
    return group;
  }


} // end of SuiteBuilder class
